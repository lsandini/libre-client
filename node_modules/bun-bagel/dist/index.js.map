{
  "version": 3,
  "sources": ["../src/constants.ts", "../src/utils.ts", "../src/mock.ts"],
  "sourcesContent": [
    "import { MockOptions } from \"./types\";\n\n/**\n * The default value for mock options.\n */\nexport const DEFAULT_MOCK_OPTIONS: MockOptions = {\n    method: 'GET',\n    data: null,\n    headers: new Headers(),\n};\n\n/**\n * Map of status codes to status text.\n */\nexport const STATUS_TEXT_MAP = {\n    200: \"OK\",\n    201: \"Created\",\n    204: \"No Content\",\n    304: \"Not Modified\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    405: \"Method Not Allowed\",\n    409: \"Conflict\",\n    418: \"I'm a teapot\",\n    422: \"Unprocessable Entity\",\n    429: \"Too Many Requests\",\n    500: \"Internal Server Error\",\n    503: \"Service Unavailable\",\n};",
    "import { DEFAULT_MOCK_OPTIONS, STATUS_TEXT_MAP } from \"./constants\";\nimport { MockOptions } from \"./types\";\n\n/**\n * @description Convert a wildcard string to a regular expression.\n * @param wildcardString - The wildcard string to convert. eg. '/api/*\\/users'\n * @returns A regular expression that matches the wildcard string.\n */\nexport function wildcardToRegex(wildcardString: string): RegExp {\n    // Escape special regex characters\n    const escapedString = wildcardString.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n    // Convert wildcard stars to regex patterns\n    const regexPattern = escapedString.replace(/\\\\\\*/g, \"[\\\\s\\\\S]*\");\n\n    // Anchor pattern for strict path matching\n    const anchoredPattern = `${regexPattern}$`;\n\n    return new RegExp(anchoredPattern);\n}\n\n/**\n * @description Find a requests.\n */\nexport const findRequest = (original: [string, RequestInit?]) => (mocked: [RegExp, MockOptions?]) => {\n    const [keyA, optionsA] = original;\n    const [keyB, optionsB] = mocked;\n\n    // Match keys.\n    const keysMatch = keyA.toString() === keyB.toString() || keyA.match(keyB);\n\n    if(!keysMatch)\n        return false;\n\n    // Match methods.\n    const methodA = optionsA?.method || \"GET\";\n    const methodB = optionsB?.method || \"GET\";\n\n    const methodMatch = methodA.toLowerCase() === methodB.toLowerCase();\n\n    if(!methodMatch)\n        return false;\n\n    // Match headers.\n    const headersA = new Headers(optionsA?.headers);\n    const headersB = new Headers(optionsB?.headers);\n\n    const headersMatch = [...headersB.entries()].every(([key, valueB]) => {\n        const valueA = headersA.get(key);\n        return valueA === valueB;\n    });\n\n    if(!headersMatch)\n        return false;\n\n    return true;\n}\n\n/**\n * Returns an object similar to Response class.\n * @param status - The HTTP status code of the response.\n * @param url - The URL of the request.\n * @param options - The options for the mocked request.\n * @returns An object similar to Response class.\n */\nexport const makeResponse = (status: keyof typeof STATUS_TEXT_MAP, url: string, options: MockOptions = DEFAULT_MOCK_OPTIONS) => {\n    const { headers, data } = options;\n\n    const ok = status >= 200 && status < 300;\n\n    return {\n        ok,\n        status,\n        statusText: STATUS_TEXT_MAP[status],\n        url,\n        headers,\n        text: () => Promise.resolve(data),\n        json: () => Promise.resolve(data),\n        redirected: false,\n        bodyUsed: !!data\n    };\n}",
    "import { DEFAULT_MOCK_OPTIONS } from \"./constants\";\nimport { MockOptions } from \"./types\";\nimport { findRequest, makeResponse, wildcardToRegex } from \"./utils\";\n\nlet ORIGINAL_FETCH: (request: Request, init?: RequestInit | undefined) => Promise<Response>;\n\n/**\n * The cache for registered mocked requests.\n */\nconst MOCKED_REQUESTS = new Map<RegExp, MockOptions>();\n\n/**\n * @description Mock the fetch method.\n */\nexport const mock = (request: Request | RegExp | string, options: MockOptions = DEFAULT_MOCK_OPTIONS) => {\n    const input = request instanceof Request ? request.url : request;\n\n    // Create regex class from input.\n    const regexInput = input instanceof RegExp ? input : new RegExp(wildcardToRegex(input.toString()));\n\n    // Check if request is already mocked.\n    const isRequestMocked = [...MOCKED_REQUESTS.entries()].find(findRequest([regexInput.toString(), options]));\n\n    if (!isRequestMocked) {\n        // Use regex as key.\n        MOCKED_REQUESTS.set(regexInput, options);\n\n        if(process.env.VERBOSE) {\n            console.debug(\"\\x1b[1mRegistered mocked request\\x1b[0m\");\n            console.debug(\"\\x1b[2mPath Pattern\\x1b[0m\", regexInput);\n            console.debug(\"\\x1b[2mMethod\\x1b[0m\", options.method);\n            console.debug(\"\\n\");\n        }\n    } else {\n        if(process.env.VERBOSE)\n            console.debug(\"\\x1b[1mRequest already mocked\\x1b[0m\", regexInput);\n        return;\n    }\n\n    if (!ORIGINAL_FETCH) {\n        // Cache the original fetch method before mocking it. Might be useful in the future to clean the mock.\n        ORIGINAL_FETCH = globalThis.fetch;\n\n        // @ts-ignore\n        globalThis.fetch = MOCKED_FETCH;\n    }\n}\n\n/**\n * @description Clear the fetch mock.\n */\nexport const clearMocks = () => {\n    MOCKED_REQUESTS.clear();\n    // @ts-ignore\n    globalThis.fetch = ORIGINAL_FETCH;\n    // @ts-ignore\n    ORIGINAL_FETCH = undefined;\n}\n\n/**\n * @description A mocked fetch method.\n */\nconst MOCKED_FETCH = async (_request: Request | RegExp | string, init?: RequestInit) => {\n    const _path = _request instanceof Request ? _request.url : _request.toString();\n\n    // When the request it fired, check if it matches a mocked request.\n    const mockedRequest = [...MOCKED_REQUESTS.entries()].find(findRequest([_path, init]));\n\n    if (!mockedRequest)\n        return Promise.reject(makeResponse(404, _path));\n\n    if(process.env.VERBOSE)\n        console.debug(\"\\x1b[2mMocked fetch called\\x1b[0m\", _path);\n\n    return makeResponse(200, _path, mockedRequest[1]);\n};\n\n"
  ],
  "mappings": ";AAKO,IAAM,EAAoC,CAC7C,OAAQ,MACR,KAAM,KACN,QAAS,IAAI,OACjB,EAKa,EAAkB,CAC3B,IAAK,KACL,IAAK,UACL,IAAK,aACL,IAAK,eACL,IAAK,cACL,IAAK,eACL,IAAK,YACL,IAAK,YACL,IAAK,qBACL,IAAK,WACL,IAAK,eACL,IAAK,uBACL,IAAK,oBACL,IAAK,wBACL,IAAK,qBACT,ECtBO,SAAS,CAAe,CAAC,EAAgC,CAQ5D,MAAM,EAAkB,GANF,EAAe,QAAQ,sBAAuB,MAAM,EAGvC,QAAQ,QAAS,WAAW,MAK/D,OAAO,IAAI,OAAO,CAAe,EAM9B,IAAM,EAAc,CAAC,IAAqC,CAAC,IAAmC,CACjG,MAAO,EAAM,GAAY,GAClB,EAAM,GAAY,EAKzB,KAFkB,EAAK,SAAS,IAAM,EAAK,SAAS,GAAK,EAAK,MAAM,CAAI,GAGpE,MAAO,GAGX,MAAM,EAAU,GAAU,QAAU,MAC9B,EAAU,GAAU,QAAU,MAIpC,GAFoB,EAAQ,YAAY,IAAM,EAAQ,YAAY,EAG9D,MAAO,GAGX,MAAM,EAAW,IAAI,QAAQ,GAAU,OAAO,EAQ9C,IALqB,CAAC,GAFL,IAAI,QAAQ,GAAU,OAAO,EAEZ,QAAQ,CAAC,EAAE,MAAM,EAAE,EAAK,KAAY,CAElE,OADe,EAAS,IAAI,CAAG,IACb,EACrB,EAGG,MAAO,GAEX,MAAO,IAUE,EAAe,CAAC,EAAsC,EAAa,EAAuB,IAAyB,CAC5H,MAAQ,UAAS,QAAS,EAI1B,MAAO,CACH,GAHO,GAAU,KAAO,EAAS,IAIjC,SACA,WAAY,EAAgB,GAC5B,MACA,UACA,KAAM,IAAM,QAAQ,QAAQ,CAAI,EAChC,KAAM,IAAM,QAAQ,QAAQ,CAAI,EAChC,WAAY,GACZ,WAAY,CAChB,GC5EJ,IAAI,EAKE,EAAkB,IAAI,IAKf,EAAO,CAAC,EAAoC,EAAuB,IAAyB,CACrG,MAAM,EAAQ,aAAmB,QAAU,EAAQ,IAAM,EAGnD,EAAa,aAAiB,OAAS,EAAQ,IAAI,OAAO,EAAgB,EAAM,SAAS,CAAC,CAAC,EAKjG,IAFwB,CAAC,GAAG,EAAgB,QAAQ,CAAC,EAAE,KAAK,EAAY,CAAC,EAAW,SAAS,EAAG,CAAO,CAAC,CAAC,GAMrG,GAFA,EAAgB,IAAI,EAAY,CAAO,EAEpC,QAAQ,IAAI,QACX,QAAQ,MAAM,yCAAyC,EACvD,QAAQ,MAAM,6BAA8B,CAAU,EACtD,QAAQ,MAAM,uBAAwB,EAAQ,MAAM,EACpD,QAAQ,MAAM,IAAI,MAEnB,CACH,GAAG,QAAQ,IAAI,QACX,QAAQ,MAAM,uCAAwC,CAAU,EACpE,OAGJ,IAAK,EAED,EAAiB,WAAW,MAG5B,WAAW,MAAQ,GAOd,EAAa,IAAM,CAC5B,EAAgB,MAAM,EAEtB,WAAW,MAAQ,EAEnB,EAAiB,QAMf,EAAe,MAAO,EAAqC,IAAuB,CACpF,MAAM,EAAQ,aAAoB,QAAU,EAAS,IAAM,EAAS,SAAS,EAGvE,EAAgB,CAAC,GAAG,EAAgB,QAAQ,CAAC,EAAE,KAAK,EAAY,CAAC,EAAO,CAAI,CAAC,CAAC,EAEpF,IAAK,EACD,OAAO,QAAQ,OAAO,EAAa,IAAK,CAAK,CAAC,EAElD,GAAG,QAAQ,IAAI,QACX,QAAQ,MAAM,oCAAqC,CAAK,EAE5D,OAAO,EAAa,IAAK,EAAO,EAAc,EAAE",
  "debugId": "E1DE8FA834C2C0E164756E2164756E21",
  "names": []
}