// @bun
var $={method:"GET",data:null,headers:new Headers},w={200:"OK",201:"Created",204:"No Content",304:"Not Modified",400:"Bad Request",401:"Unauthorized",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",409:"Conflict",418:"I'm a teapot",422:"Unprocessable Entity",429:"Too Many Requests",500:"Internal Server Error",503:"Service Unavailable"};function x(z){const V=`${z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/\\\*/g,"[\\s\\S]*")}\$`;return new RegExp(V)}var j=(z)=>(Y)=>{const[J,V]=z,[Z,b]=Y;if(!(J.toString()===Z.toString()||J.match(Z)))return!1;const G=V?.method||"GET",Q=b?.method||"GET";if(G.toLowerCase()!==Q.toLowerCase())return!1;const P=new Headers(V?.headers);if(![...new Headers(b?.headers).entries()].every(([f,H])=>{return P.get(f)===H}))return!1;return!0},v=(z,Y,J=$)=>{const{headers:V,data:Z}=J;return{ok:z>=200&&z<300,status:z,statusText:w[z],url:Y,headers:V,text:()=>Promise.resolve(Z),json:()=>Promise.resolve(Z),redirected:!1,bodyUsed:!!Z}};var W,X=new Map,m=(z,Y=$)=>{const J=z instanceof Request?z.url:z,V=J instanceof RegExp?J:new RegExp(x(J.toString()));if(![...X.entries()].find(j([V.toString(),Y]))){if(X.set(V,Y),process.env.VERBOSE)console.debug("\x1B[1mRegistered mocked request\x1B[0m"),console.debug("\x1B[2mPath Pattern\x1B[0m",V),console.debug("\x1B[2mMethod\x1B[0m",Y.method),console.debug("\n")}else{if(process.env.VERBOSE)console.debug("\x1B[1mRequest already mocked\x1B[0m",V);return}if(!W)W=globalThis.fetch,globalThis.fetch=N},I=()=>{X.clear(),globalThis.fetch=W,W=void 0},N=async(z,Y)=>{const J=z instanceof Request?z.url:z.toString(),V=[...X.entries()].find(j([J,Y]));if(!V)return Promise.reject(v(404,J));if(process.env.VERBOSE)console.debug("\x1B[2mMocked fetch called\x1B[0m",J);return v(200,J,V[1])};export{m as mock,I as clearMocks};

//# debugId=E1DE8FA834C2C0E164756E2164756E21
